# Day 09 - Piscine SQL

## _RDBMS is not just a tables_

Resume: Today you will see how to create and use functional blocks in Databases

## Contents

1. [Глава I](#chapter-i) \
    1.1. [Преамбула](#preamble)
2. [Глава II](#chapter-ii) \
    2.1. [Основные правила](#general-rules)
3. [Глава III](#chapter-iii) \
    3.1. [Правила дня](#rules-of-the-day)  
4. [Глава IV](#chapter-iv) \
    4.1. [Упражнение 00 - Аудит входящих вставок](#exercise-00-audit-of-incoming-inserts)  
5. [Глава V](#chapter-v) \
    5.1. [Упражнение 01 - Аудит входящих обновлений](#exercise-01-audit-of-incoming-updates)  
6. [Глава VI](#chapter-vi) \
    6.1. [Упражнение 02 - Аудит входящих удалений](#exercise-02-audit-of-incoming-deletes)  
7. [Глава VII](#chapter-vii) \
    7.1. [Упражнение 03 - Общий аудит](#exercise-03-generic-audit)  
8. [Глава VIII](#chapter-viii) \
    8.1. [Упражнение 04 - Представление базы данных VS функции базы данных](#exercise-04-database-view-vs-database-function)
9. [Глава IX](#chapter-ix) \
    9.1. [Упражнение 05 - Параметризованная функция базы данных](#exercise-05-parameterized-database-function)
10. [Глава X](#chapter-x) \
    10.1. [Упражнение 06 - Функция-оболочка](#exercise-06-function-like-a-function-wrapper)
11. [Глава XI](#chapter-xi) \
    11.1. [Упражнение 07 - Другой взгляд, чтобы найти минимум](#exercise-07-different-view-to-find-a-minimum)
12. [Глава XII](#chapter-xii) \
    12.1. [Упражнение 08 - Алгоритм Фибоначчи внутри функции](#exercise-08-fibonacci-algorithm-is-in-a-function)    
      

## Глава I
## Преамбула

![D09_01](misc/images/D09_01.png)

В мире СУБД существует множество языков функционального программирования. В основном мы можем говорить о зависимости «один к одному» между конкретным движком СУБД и функциональным Языком внутри. Пожалуйста, взгляните на образец этих языков.

- T-SQL
- PL/SQL
- SQL
- PL/PGSQL
- PL/R
- PL/Python
- и т.д.

На самом деле в IT-мире существует два противоположных мнения о том, где должна располагаться бизнес-логика. Первое мнение относится к уровню приложений, второе - к СУБД, непосредственно основанным на заданных UDF (определяемых пользователем функциях/процедурах/пакетах). Каждый выбирает свой способ реализации бизнес-логики. С моей точки зрения, бизнес-логика должна быть в обоих местах, и я могу сказать, почему.
Пожалуйста, взгляните на две простые архитектуры ниже.

|  |  |
| ------ | ------ |
| ![D09_02](misc/images/D09_02.png) | Все понятно, фронтенды и бэкенды работают через специальный слой REST API, который реализует всю бизнес-логику. Это действительно идеальный мир приложений. |
| Но всегда есть какие-то привилегированные ребята/приложения (такие как IDE), которые работают напрямую с нашими базами данных и… наш шаблон может быть нарушен. | ![D09_03](misc/images/D09_03.png) |

Просто подумайте об этом и попытайтесь создать чистую архитектуру :-) 

## Глава II
## Основные правила

- Используйте эту страницу как единственную инструкцию. Не слушайте никаких слухов и домыслов о том, как подготовить своё решение.
- Пожалуйста, убедитесь, что вы используете последнюю версию PostgreSQL.
- Это совершенно нормально, если вы используете IDE для написания исходного кода (он же SQL-скрипт).
- Для оценки ваше решение должно находиться в вашем репозитории GIT.
- Ваши решения будут оценены вашими товарищами по интенсиву.
- Вы не должны оставлять в своем каталоге никаких других файлов, кроме тех, которые явно указаны в инструкциях к упражнению. Рекомендуется изменить ваш .gitignoreчтобы избежать случайностей.
- У вас есть вопрос? Спросите у соседа справа. Если не помогло - попробуйте с соседом слева.
- Ваш справочник: товарищи/интернет/гугл.
- Внимательно прочитайте примеры. Они могут понять вещи, которые иначе не указаны в задании. 
- И да прибудет с вами сила SQL!
- Абсолютно все можно представить в SQL! Давайте начнем и получайте удовольствие!

## Глава III
## Правила дня

- Убедитесь, что у вас есть собственная база данных и доступ к ней в вашем кластере PostgreSQL.
- Загрузите скрипт (materials/model.sql) с моделью базы данных здесь и примените его к своей базе данных (вы можете использовать командную строку с psql или просто запустить его через любую IDE, например DataGrip от JetBrains или pgAdmin от сообщества PostgreSQL).
- **Наш способ получения знаний является постепенным и линейным, поэтому, пожалуйста, имейте в виду, что все изменения, которые вы внесли в День03 во время упражнений 07-13 и в День04 во время Упражнение 07, должны быть на месте (это похоже на реальный мир, когда мы применили релиз и должны быть согласованы с данными для новых изменений).**
- Все задачи содержат список разрешенных и запрещенных разделов с перечисленными параметрами базы данных, типами баз данных, конструкциями SQL и т. д. Пожалуйста, ознакомьтесь с разделом перед началом.
- Пожалуйста, взгляните на логическое представление нашей модели базы данных.

![schema](misc/images/schema.png)

1. Таблица **pizzeria** (Таблица-словарь с доступными пиццериями)
- поле ``id`` - первичный ключ (primary key)
- поле ``name`` - название пиццерии
- поле ``rating`` - средний рейтинг пиццерии (от 0 до 5 баллов)
2. Таблица **person** (Таблица-словарь с людьми, которые любят пиццу)
- поле ``id`` - первичный ключ (primary key)
- поле ``name`` - имя человека
- поле ``age`` - возраст человека
- поле ``gender`` - пол человека
- поле ``address`` - адрес человека
3. Таблица **menu** (Таблица-словарь с доступным меню и ценой на конкретную пиццу)
- поле ``id`` - первичный ключ (primary key)
- поле ``pizzeria_id`` - внешний ключ к пиццерии
- поле ``pizza_name`` - название пиццы в пиццерии
- поле ``price`` - цена конкретной пиццы
4. Таблица **person_visits** (Операционная таблица с информацией о посещениях пиццерии)
- поле ``id`` - первичный ключ (primary key)
- поле ``person_id`` - внешний ключ к человеку
- поле ``pizzeria_id`` - внешний ключ к пиццерии
- поле ``visit_date`` - дата (например 2022-01-01) посещения пиццерии человеком
5. Таблица **person_order** (операционная таблица с информацией о заказах людей)
- поле ``id`` - первичный ключ (primary key)
- поле ``person_id`` - внешний ключ к человеку
- поле ``menu_id`` - внешний ключ к меню
- поле ``order_date`` - дата (например 2022-01-01) заказа человека

Посещение (visit_date) и заказ (order_date) - это разные сущности, и нет никакой корреляции между их данными. Например, клиент может находиться в одном месте (просто просматривая меню) и в это время сделать заказ в другом по телефону или с помощью мобильного приложения. Или позвонить из дома с заказом без каких-либо визитов.

## Глава IV
## Упражнение 00 - Аудит входящих вставок

| Упражнение 00: Аудит входящих вставок |                                                                                                                          |
|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Каталог сдачи                     | ex00                                                                                                                     |
| Файлы для сдачи                      | `day09_ex00.sql`                                                                                 |
| **Разрешено**                               |                                                                                                                          |
| Язык                        | SQL, DDL, DML|

Мы хотим быть сильнее с данными и не хотим терять ни одно событие изменений. Давайте реализуем функцию аудита для входящих изменений INSERT. Пожалуйста, создайте таблицу `person_audit` с той же структурой, что и таблица людей, но добавьте несколько дополнительных изменений. Взгляните на таблицу ниже с описаниями для каждого столбца.

| Column | Type | Description |
| ------ | ------ | ------ |
| created | timestamp with time zone | метка времени создания нового события. Значение по умолчанию — текущая метка времени, и NOT NULL. |
| type_event | char(1) | возможные значения I (вставить), D (удалить), U (обновить). Значение по умолчанию — «Я». НЕ НОЛЬ. Добавить контрольное ограничение  `ch_type_event`с возможными значениями «I», «U» и «D» |
| row_id |bigint | копия person.id. NOT NULL |
| name |varchar | копия person.name (без каких-либо ограничений) |
| age |integer | копия person.age (без каких-либо ограничений) |
| gender |varchar | копия person.gender (без каких-либо ограничений) |
| address |varchar | копия person.address (без каких-либо ограничений) |

Собственно, давайте создадим триггерную функцию базы данных с именем `fnc_trg_person_insert_audit` который должен обрабатывать `INSERT` DML-трафик и сделайте копию новой строки в таблице person_audit.

Просто подсказка: если вы хотите реализовать триггер PostgreSQL (пожалуйста, прочтите его в документации PostgreSQL), вам нужно создать 2 объекта: функцию триггера базы данных и триггер базы данных.

Поэтому, пожалуйста, определите триггер базы данных с именем `trg_person_insert_audit` со следующими вариантами

- триггер с опцией «ДЛЯ КАЖДОЙ СТРОКИ» (“FOR EACH ROW”)
- триггер с “AFTER INSERT”
- триггер вызывает триггерную функцию `fnc_trg_person_insert_audit`

Когда вы будете готовы с триггерными объектами, пожалуйста, создайте выражение `INSERT` в таблицу `person`. 
`INSERT INTO person(id, name, age, gender, address) VALUES (10,'Damir', 22, 'male', 'Irkutsk');`


## Глава V
## Упражнение 01 - Аудит входящих обновлений

| Упражнение 01: Аудит входящих обновлений|                                                                                                                          |
|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Каталог сдачи                     | ex01                                                                                                                     |
| Файлы для сдачи                      | `day09_ex01.sql`                                                                                 |
| **Разрешено**                               |                                                                                                                          |
| Язык                        | SQL, DDL, DML                                                                                              |

Давайте продолжим реализацию нашего шаблона аудита для таблицы person. Просто определите триггер `trg_person_update_audit`и соответствующая триггерная функция `fnc_trg_person_update_audit` справиться со всеми `UPDATE` траффика в таблице ``person``.  Мы должны сохранить СТАРЫЕ состояния всех значений атрибутов.

Когда вы будете готовы, пожалуйста, примените утверждения UPDATE ниже.

`UPDATE person SET name = 'Bulat' WHERE id = 10;`
`UPDATE person SET name = 'Damir' WHERE id = 10;`


## Глава VI
## Упражнение 02 - Аудит входящих удалений

| Упражнение 02: Аудит входящих удалений|                                                                                                                          |
|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Каталог сдачи                     | ex02                                                                                                                     |
| Файлы для сдачи                      | `day09_ex02.sql`                                                                                 |
| **Разрешено**                               |                                                                                                                          |
| Язык                        | SQL, DDL, DML                                                                                              |

Наконец, нам нужно обработать операторы `DELETE` и сделать копию СТАРЫХ состояний для всех значений атрибута. Пожалуйста, создайте триггер `trg_person_delete_audit` и соответствующую триггерную функцию `fnc_trg_person_delete_audit`. 

Когда вы будете готовы, пожалуйста, примените оператор SQL ниже.

`DELETE FROM person WHERE id = 10;`

## Глава VII
## Упражнение 03 - Общий аудит

| Упражнение 03: Общий аудит |                                                                                                                          |
|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Каталог сдачи                     | ex03                                                                                                                     |
| Файлы для сдачи                      | `day09_ex03.sql`                                                                                 |
| **Разрешено**                               |                                                                                                                          |
| Язык                        | SQL, DDL, DML                                                                                              |

На самом деле, есть 3 триггера для одной таблицы `person`.  Объединим всю нашу логику в один главный триггер с названием `trg_person_audit` и новую соответствующую триггерную функцию `fnc_trg_person_audit`.

Другими словами, весь DML-трафик (`INSERT`, `UPDATE`, `DELETE`) должны обрабатываться из одного функционального блока. Пожалуйста, явно определите отдельный блок IF-ELSE для каждого события (I, U, D)!

Кроме того, выполните следующие действия.
- удалите 3 старых триггера из таблицы лиц. 
- удалите 3 старые триггерные функции 
- сделайте `TRUNCATE` (или `DELETE`) всех строк в нашей таблице `person_audit`.

Когда вы будете готовы, повторно примените набор операторов DML.
`INSERT INTO person(id, name, age, gender, address)  VALUES (10,'Damir', 22, 'male', 'Irkutsk');`
`UPDATE person SET name = 'Bulat' WHERE id = 10;`
`UPDATE person SET name = 'Damir' WHERE id = 10;`
`DELETE FROM person WHERE id = 10;`


## Глава VIII
## Упражнение 04 - Представление базы данных VS функции базы данных


| Упражнение 04: Представление базы данных VS функции базы данных |                                                                                                                          |
|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Каталог сдачи                     | ex04                                                                                                                     |
| Файлы для сдачи                      | `day09_ex04.sql`                                                                                 |
| **Разрешено**                               |                                                                                                                          |
| Язык                        | SQL, DDL, DML                                                                                              |

Как вы помните, мы создали 2 представления базы данных, чтобы отделить данные от таблиц лиц по признаку пола. Пожалуйста, определите 2 SQL-функции (обратите внимание, не pl/pgsql-функции) с именами.

- `fnc_persons_female` (должны быть возвращены лица женского пола)
- `fnc_persons_male` (должны возвращаться лица мужского пола)

Чтобы проверить себя и вызвать функцию, вы можете сделать оператор, как показано ниже (удивительно! вы можете работать с функцией, как с виртуальной таблицей!).

    SELECT *
    FROM fnc_persons_male();

    SELECT *
    FROM fnc_persons_female();


## Глава IX
## Упражнение 05 - Параметризованная функция базы данных


| Упражнение 05: Параметризованная функция базы данных|                                                                                                                          |
|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Каталог сдачи                     | ex05                                                                                                                     |
| Файлы для сдачи                      | `day09_ex05.sql`                                                                                 |
| **Разрешено**                               |                                                                                                                          |
| Язык                        |  SQL, DDL, DML                                                                                               |

Похоже, две функции из Упражнения 04 нуждаются в более общем подходе. Пожалуйста, перед нашими дальнейшими шагами удалите эти функции из базы данных. Напишите обычную SQL-функцию (обратите внимание, не pl/pgsql-функцию) с именем `fnc_persons`.  Эта функция должна иметь `IN`параметр pgender со значением по умолчанию = 'женский'.

Чтобы проверить себя и вызвать функцию, вы можете сделать оператор, как показано ниже (вау! вы можете работать с функцией, как с виртуальной таблицей, но с большей гибкостью!).

```
    select *
    from fnc_persons(pgender := 'male');

    select *
    from fnc_persons();
```

## Глава X
## Упражнение 06 - Функция-оболочка


| Упражнение 06: Функция-оболочка|                                                                                                                          |
|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Каталог сдачи                     | ex06                                                                                                                     |
| Файлы для сдачи                      | `day09_ex06.sql`                                                                                 |
| **Разрешено**                               |                                                                                                                          |
| Язык                        | SQL, DDL, DML                                                                                              |

Давайте прямо сейчас посмотрим на функции pl/pgsql.

Пожалуйста, создайте функцию pl/pgsql `fnc_person_visits_and_eats_on_date` на основе оператора SQL, который находит названия пиццерий, которые человек (`IN` параметр pperson со значением по умолчанию 'Дмитрий') посетил и купил пиццу на сумму меньше указанной в рублях (`IN` параметр pprice со значением по умолчанию 500) на конкретную дату (`IN` параметр pdate со значением по умолчанию — 8 января 2022 г.).

Чтобы проверить себя и вызвать функцию, вы можете сделать оператор, как показано ниже.

```
    select *
    from fnc_person_visits_and_eats_on_date(pprice := 800);

    select *
    from fnc_person_visits_and_eats_on_date(pperson := 'Anna',pprice := 1300,pdate := '2022-01-01');
```

## Глава XI
## Упражнение 07 - Другой взгляд, чтобы найти минимум


| Упражнение 07: Другой взгляд, чтобы найти минимум|                                                                                                                          |
|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Каталог сдачи                     | ex07                                                                                                                     |
| Файлы для сдачи                      | `day09_ex07.sql`                                                                                 |
| **Разрешено**                               |                                                                                                                          |
| Язык                        | SQL, DDL, DML                                                                                              |

Пожалуйста, напишите функцию SQL или pl/pgsql `func_minimum` (на ваше усмотрение) у которого входной параметр представляет собой массив чисел и функция должна возвращать минимальное значение.

Чтобы проверить себя и вызвать функцию, вы можете сделать оператор, как показано ниже.

```
    SELECT func_minimum(VARIADIC arr => ARRAY[10.0, -1.0, 5.0, 4.4]);
```

## Глава XII
## Упражнение 08 - Алгоритм Фибоначчи внутри функции


| Упражнение 08: Алгоритм Фибоначчи внутри функции|                                                                                                                          |
|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Каталог сдачи                     | ex08                                                                                                                     |
| Файлы для сдачи                      | `day09_ex08.sql`                                                                                 |
| **Разрешено**                               |                                                                                                                          |
| Язык                        | SQL, DDL, DML                                                                                              |

Пожалуйста, напишите функцию SQL или pl/pgsql `fnc_fibonacci` (на ваше усмотрение), у которого есть входной параметр pstop с типом integer (по умолчанию 10), а выходом функции является таблица со всеми числами Фибоначчи меньше pstop.

Чтобы проверить себя и вызвать функцию, вы можете сделать утверждения, как показано ниже.

```
    select * from fnc_fibonacci(100);
    select * from fnc_fibonacci();
```
